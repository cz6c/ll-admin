import { isArray, isNumber } from "@/utils/is";

/**
 * @description ç”Ÿæˆå”¯ä¸€ uuid
 * @returns {String}
 */
export function generateUUID() {
  let uuid = "";
  for (let i = 0; i < 32; i++) {
    const random = (Math.random() * 16) | 0;
    if (i === 8 || i === 12 || i === 16 || i === 20) uuid += "-";
    uuid += (i === 12 ? 4 : i === 16 ? (random & 3) | 8 : random).toString(16);
  }
  return uuid;
}

/**
 * @description ç”Ÿæˆéšæœºæ•°
 * @param {Number} min æœ€å°å€¼
 * @param {Number} max æœ€å¤§å€¼
 * @returns {Number}
 */
export function randomNum(min: number, max: number): number {
  const num = Math.floor(Math.random() * (min - max) + max);
  return num;
}

/**
 * @description è·å–å½“å‰æ—¶é—´å¯¹åº”çš„æç¤ºè¯­
 * @returns {String}
 */
export function getTimeState(): string {
  const timeNow = new Date();
  const hours = timeNow.getHours();
  if (hours >= 6 && hours <= 10) return `æ—©ä¸Šå¥½ â›…`;
  if (hours >= 10 && hours <= 14) return `ä¸­åˆå¥½ ğŸŒ`;
  if (hours >= 14 && hours <= 18) return `ä¸‹åˆå¥½ ğŸŒ`;
  if (hours >= 18 && hours <= 24) return `æ™šä¸Šå¥½ ğŸŒ›`;
  if (hours >= 0 && hours <= 6) return `å‡Œæ™¨å¥½ ğŸŒ›`;
  return "";
}

/**
 * @description å¤„ç†å€¼æ— æ•°æ®æƒ…å†µ
 * @param {*} callValue éœ€è¦å¤„ç†çš„å€¼
 * @returns {String}
 * */
export function formatValue(callValue: any): string {
  // å¦‚æœå½“å‰å€¼ä¸ºæ•°ç»„ï¼Œä½¿ç”¨ / æ‹¼æ¥ï¼ˆæ ¹æ®éœ€æ±‚è‡ªå®šä¹‰ï¼‰
  if (isArray(callValue)) return callValue.length ? callValue.join(" / ") : "--";
  return callValue ?? "--";
}

/**
 * @description å¤„ç† prop ä¸ºå¤šçº§åµŒå¥—çš„æƒ…å†µï¼Œè¿”å›çš„æ•°æ® (åˆ—å¦‚: prop: user.name)
 * @param {Object} row å½“å‰è¡Œæ•°æ®
 * @param {String} prop å½“å‰ prop
 * @returns {*}
 * */
export function handleRowAccordingToProp(row: { [key: string]: any }, prop: string): any {
  if (!prop.includes(".")) return row[prop] ?? "--";
  prop.split(".").forEach(item => (row = row[item] ?? "--"));
  return row;
}

/**
 * @description å¤„ç† propï¼Œå½“ prop ä¸ºå¤šçº§åµŒå¥—æ—¶ ==> è¿”å›æœ€åä¸€çº§ prop
 * @param {String} prop å½“å‰ prop
 * @returns {String}
 * */
export function handleProp(prop: string): string {
  const propArr = prop.split(".");
  if (propArr.length == 1) return prop;
  return propArr[propArr.length - 1];
}

/**
 * @description: æ‰“å¼€æ–°çª—å£
 */
export function openWindow(
  url: string,
  opt?: {
    target?: TargetContext | string;
    noopener?: boolean;
    noreferrer?: boolean;
  }
) {
  const { target = "__blank", noopener = true, noreferrer = true } = opt || {};
  const feature: string[] = [];

  noopener && feature.push("noopener=yes");
  noreferrer && feature.push("noreferrer=yes");

  window.open(url, target, feature.join(","));
}

/**
 * @description: enumæ•°æ®è½¬opts
 * @param data
 */
export function enumToOpts(data: unknown) {
  return Object.entries(data)
    .filter(([, value]) => isNumber(value))
    .map(([label, value]) => ({ value, label }));
}

// æ—¥æœŸæ ¼å¼åŒ–
export function parseTime(time, pattern = "{y}-{m}-{d} {h}:{i}:{s}") {
  if (arguments.length === 0 || !time) {
    return null;
  }
  const format = pattern;
  let date;
  if (typeof time === "object") {
    date = time;
  } else {
    if (typeof time === "string" && /^[0-9]+$/.test(time)) {
      time = parseInt(time);
    } else if (typeof time === "string") {
      time = time
        .replace(new RegExp(/-/gm), "/")
        .replace("T", " ")
        .replace(new RegExp(/\.[\d]{3}/gm), "");
    }
    if (typeof time === "number" && time.toString().length === 10) {
      time = time * 1000;
    }
    date = new Date(time);
  }
  const formatObj = {
    y: date.getFullYear(),
    m: date.getMonth() + 1,
    d: date.getDate(),
    h: date.getHours(),
    i: date.getMinutes(),
    s: date.getSeconds(),
    a: date.getDay()
  };
  const time_str = format.replace(/{(y|m|d|h|i|s|a)+}/g, (result, key) => {
    let value = formatObj[key];
    // Note: getDay() returns 0 on Sunday
    if (key === "a") {
      return ["æ—¥", "ä¸€", "äºŒ", "ä¸‰", "å››", "äº”", "å…­"][value];
    }
    if (result.length > 0 && value < 10) {
      value = "0" + value;
    }
    return value || 0;
  });
  return time_str;
}

/**
 * @description: æ—¥æœŸèŒƒå›´å¤„ç†
 */
export function addDateRange(params, dateRange) {
  let search = params;
  dateRange = Array.isArray(dateRange) ? dateRange : [];
  search["beginTime"] = dateRange[0];
  search["endTime"] = dateRange[1];
  return search;
}

// å›æ˜¾æ•°æ®å­—å…¸
export function selectDictLabel(datas, value) {
  if (value === undefined) {
    return "";
  }
  var actions = [];
  Object.keys(datas).some(key => {
    if (datas[key].value == "" + value) {
      actions.push(datas[key].label);
      return true;
    }
  });
  if (actions.length === 0) {
    actions.push(value);
  }
  return actions.join("");
}

// å›æ˜¾æ•°æ®å­—å…¸ï¼ˆå­—ç¬¦ä¸²æ•°ç»„ï¼‰
export function selectDictLabels(datas, value, separator) {
  if (value === undefined || value.length === 0) {
    return "";
  }
  if (Array.isArray(value)) {
    value = value.join(",");
  }
  var actions = [];
  var currentSeparator = undefined === separator ? "," : separator;
  var temp = value.split(currentSeparator);
  Object.keys(value.split(currentSeparator)).some(val => {
    var match = false;
    Object.keys(datas).some(key => {
      if (datas[key].value == "" + temp[val]) {
        actions.push(datas[key].label + currentSeparator);
        match = true;
      }
    });
    if (!match) {
      actions.push(temp[val] + currentSeparator);
    }
  });
  return actions.join("").substring(0, actions.join("").length - 1);
}

// å­—ç¬¦ä¸²æ ¼å¼åŒ–(%s )
export function sprintf(str) {
  var args = arguments,
    flag = true,
    i = 1;
  str = str.replace(/%s/g, function () {
    var arg = args[i++];
    if (typeof arg === "undefined") {
      flag = false;
      return "";
    }
    return arg;
  });
  return flag ? str : "";
}

/**
 * @description: è½¬æ¢å­—ç¬¦ä¸²ï¼Œundefined,nullç­‰è½¬åŒ–ä¸º""
 */
export function parseStrEmpty(str: string): string {
  if (!str || str == "undefined" || str == "null") {
    return "";
  }
  return str;
}

// æ•°æ®åˆå¹¶
export function mergeRecursive(source, target) {
  for (var p in target) {
    try {
      if (target[p].constructor == Object) {
        source[p] = mergeRecursive(source[p], target[p]);
      } else {
        source[p] = target[p];
      }
    } catch (e) {
      source[p] = target[p];
    }
  }
  return source;
}

/**
 * @description: getè¯·æ±‚å‚æ•°å¤„ç†
 */
export function tansParams(params) {
  let result = "";
  for (const propName of Object.keys(params)) {
    const value = params[propName];
    var part = encodeURIComponent(propName) + "=";
    if (value !== null && value !== "" && typeof value !== "undefined") {
      if (typeof value === "object") {
        for (const key of Object.keys(value)) {
          if (value[key] !== null && value[key] !== "" && typeof value[key] !== "undefined") {
            let params = propName + "[" + key + "]";
            var subPart = encodeURIComponent(params) + "=";
            result += subPart + encodeURIComponent(value[key]) + "&";
          }
        }
      } else {
        result += part + encodeURIComponent(value) + "&";
      }
    }
  }
  return result.slice(0, -1);
}
